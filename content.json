{"pages":[{"title":"404 Not Found：该页无法显示","text":"404 Not Found：该页无法显示","link":"/404.html"},{"title":"关于我","text":"小弟读过两年书","link":"/about/index.html"}],"posts":[{"title":"命名空间","text":"什么是命名空间简单来说，PHP中的命名空间就是用于解决多个命名重名冲突的一种语法结构。其相当于虚拟的层级目录结构，只要顶层命名不同，其下的命名就算相同也会被区分开来。 为什么要使用命名空间要回答这个问题呢，当我们明白了引入命名空间带来的好处，也就豁然开朗：“哦，原来是这样啊，也就这么回事”。 其实命名空间的概念早在5.x的时代就已引入。不过在此之前，PHP为解决重名问题（我们的代码可能和其他开发者的代码使用相同的类名、接口名、函数或常量名，这样就会导致PHP执行出错），比如类名重名时，通常会在定义类名时加上一大串前缀，在调用类时同样如是。 比如早期的zend framework框架： 12345$acl = new Zend_Acl();$acl-&gt;addRole(new Zend_Acl_Role('guest')) -&gt;addRole(new Zend_Acl_Role('member')) -&gt;addRole(new Zend_Acl_Role('admin')); 其类名Zend_Acl、Zend_Acl_Role，为了避免重名冲突，在本身简单类名前面加上了厂商命名和功能模块命名，以致于代码中多处调用时显得格外的臃肿。 为此，命名空间应运而生，它解决了这两类问题： 用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。 为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。 怎么使用命名空间定义命名空间命名空间通过关键字namespace来定义。如果一个文件中包含命名空间，那么它必须在其它所有代码之前定义命名空间。其下的PHP类、接口、函数和常量都在该命名空间当中。 12345namespace yii\\di;class Container { // ...} 上面代码定义了命名空间为 yii\\di，然后在其下定义了一个类Container，该类完整的类名包括它所属的命名空间，即yii\\di\\Container。 命名空间很好的解决了类的重名问题，比如我们下面同样定义了一个Container类，定义的类名相同，但所属的命名空间不同，所以与上面的类并不会重名冲突。 12345namespace my\\test;class Container { // ...} 导入/别名引入命名空间后，虽然在定义类名时好像命名短了一点，但其实加上命名空间之后，类名同样冗长，比如my\\test\\Container。为了避免在调用该类时使用过长的类名，可以使用use关键字进行导入。 123use my\\test\\Container;$c = new Container(); 我们在创建类的对象时，由于通过了use导入类，所以new了一个很简短的类名，就相当于： 1$c = new \\my\\test\\Container(); 另外，还可以在导入类时创建别名，同于进一步解决导入重名问题或是让命名更简单一些。别名使用as关键字： 12345use yii\\di\\Container as YiiCon;use my\\test\\Container as MyCon;$c1 = new YiiCon();$c2 = new MyCon(); 命名空间的意义命名空间的引入，让PHP代码编写起来更加的规范，跟其它语言一样有了类似于“包”的概念，可以说，命名空间的引入是现代PHP生态的基础。 按照面向对象编程的思想来讲，命名空间也是一种封装事物的方法，类似于目录结构，让目录中的文件有了各自的空间。通常在现代PHP代码设计中，一个命名空间的定义跟它所在的目录结构就是一种对应关系，这样设计的目的主要有两个原因： 将文件“物理隔离”，让PHP文件分隔在不同的目录中，比如相似功能的文件放在同一目录中，既方便管理又代码整洁。 根据命名空间很轻易地就能找到对应的目录，这不仅是在人工查找方面上还是在代码设计中的“自动加载（autoload）”上，都能轻易地实现。 1namespace app\\controllers; 上面定义了命名空间app\\controllers，那么在代码设计中就应该有app/controllers这么一个目录结构。 更多关于命名空间的资料可以参考PHP手册：https://www.php.net/manual/zh/language.namespaces.php","link":"/modern-php/basics/namespace/"},{"title":"面向接口编程","text":"什么是面向接口编程在代码设计中，我们现在常常听到的就是“面向接口编程”。什么是面向接口编程呢？它其实也就是一种“编程思想”，同样属于面向对象编程思想。 接口interface是将“对象”进一步抽象的概念，但接口并不是无原则的抽象，也强调一种规范、一种契约。 一个经典的例子就是USB接口，与我们编程中所说的接口意思差不多。各种品牌的计算机都按照USB接口“某种规范”留有USB插槽，各种U盘生产商也按照“某种规范”生产，这样一来，随便一个U盘都是插上任意一台计算机上进行工作。 为什么要面向接口编程上面一个USB接口的例子虽是现实生活中的一种工业设计思想，但在我们编程当中，该思想同样受用。 在程序设计中，将对象抽象出接口，可以让接口来进行更松散类型匹配，而扩展对象则按照接口契约进行，从而最大限度地进行代码上的解耦。这就是面向接口编程的基本思想，也是面向对象编程思想体系中最精髓的部分。 好的编程设计在处理类与类的依赖关系时，基本都是将类的外部依赖用接口的方式来注入，而避免直接用对象的方式写死。这样在以后的程序修改和扩展中，我们不必处处修改类与类的依赖关系，修改和扩展更显得游刃有余。 怎么运用面向接口编程我们用一个简单的例子来模拟一下面向接口编程：动物饲养员喂养动物。 比如，动物员里有两种动物：熊猫（Panda）、老虎（Tiger），饲养员（Zooman）要喂养它们。如果不使用接口，可能我们会这样设计： 123456789class Zooman { public function feed($what) { if ($what == 'panda') { // TODO } else if ($what == 'tiger') [ // TODO } }} 这时候如果动物园里再引入一种新动物猴子（Monkey），饲养员要喂养它是不是又要在Zooman类中增加一层判断呢？如果有引入了更多的动物呢？这样的代码非常不利于业务的扩展。 我们采用接口来将上面的例子进行重构，首先我们抽象出一个动物接口AnimalInterface，让所有的动物都去实现这个接口： 12345678910111213interface AnimalInterface { public function eat();}class Panda implements AnimalInterface { public function eat() { // TODO }}class Tiger implements AnimalInterface { public function eat() { // TODO }} 然后我们在Zooman类中的feed方法中采用接口的方式来注入外部依赖，也就是动物AnimalInterface： 12345class Zooman { public function feed(AnimalInterface $animal) { $animal-&gt;eat(); }} 在feed方法具体调用的时候，会根据AnimalInterface接口的具体的实现类（Panda或者Tiger）来进行业务切换。 1234// 喂养老虎(new Zooman())-&gt;feed(new Tiger());// 喂养熊猫(new Zooman())-&gt;feed(new Panda()); 如果以后饲养员要饲养新的动物，我们只要添加新的动物类并实现AnimalInterface接口，就能轻松地切换饲养业务，并且不用去修改原有的Zooman类。","link":"/modern-php/basics/use-interface/"},{"title":"composer简介","text":"什么是composer composer 并不是一个包管理器。是的，它涉及 “packages” 和 “libraries”，但它在每个项目的基础上进行管理，在你项目的某个目录中（例如 vendor）进行安装。默认情况下它不会在全局安装任何东西。因此，composer 仅仅是一个依赖管理。 这种想法类似于 node 的 npm，而在 composer 诞生之前 PHP 并没有类似的工具。 composer 将为我们解决如下问题： 我们有一个项目依赖于若干个库。 其中一些库依赖于其他库。 我们声明了所依赖的东西。 composer 会找出哪个版本的包需要安装，并安装它们（将它们下载到我们的项目中）。 安装 composercomposer 安装非常简单，简单来说就是三步： 下载安装脚本 运行安装脚本 删除安装脚本 linux 安装 composer首先保证安装了 PHP，然后依次输入如下命令： 123php -r &quot;copy('https://install.phpcomposer.com/installer', 'composer-setup.php');&quot;php composer-setup.phpphp -r &quot;unlink('composer-setup.php');&quot; 局部安装上述下载 composer 的过程正确执行完毕后，可以将 composer.phar 文件复制到任意目录（比如项目根目录下），然后通过 php composer.phar 指令即可使用 composer 了。 全局安装全局安装是将 composer 安装到系统环境变量 PATH 所包含的路径下面，然后就能够在命令行窗口中直接执行 composer 命令了。打开命令行窗口并执行如下命令将前面下载的 composer.phar 文件移动到 /usr/local/bin/ 目录下面： 1sudo mv composer.phar /usr/local/bin/composer windows 安装 composer首先打开命令行窗口，切换目录到 PHP 的安装目录（也就是和 php.exe 在同一级目录），在该目录下执行同 linux 安装一样的安装命令。 安装命令执行完成之后，在 PHP 安装目录下新建一个 composer.bat 文件，并将下列代码保存到此文件中： 1@php &quot;%~dp0composer.phar&quot; %* 最后重新打开一个命令行窗口，执行 composer --version ，如果能正确输出版本号就表示 composer 安装成功了。 composer 常用命令 安装包，根据 composer.json 来安装项目所依赖的代码包 1composer install 更新包，升级 composer.json 中的所有代码包（如果所依赖的代码包有更新升级的话） 1composer update 搜索包 1composer search 关键字 引入包，会在 composer.json 文件中新增一条包配置，并下载该代码包 1composer require 包名称 删除包 1composer remove 包名称 生成当前命名空间与类库文件路径的一个映射，运行时加载会直接读取这个映射，加快文件的加载速度，适用于生产环境 1composer dump-autoload -o 更多的命令参考：https://docs.phpcomposer.com/03-cli.html","link":"/modern-php/composer/introduction/"},{"title":"composer包管理","text":"我们知道，通过 composer 来安装的项目依赖都记录在 composer.json 文件中，而 composer.json 文件中我们最关心也当然也就是我们项目所需要的各种代码包了。 12345&quot;require&quot;: { &quot;fideloper/proxy&quot;: &quot;^4.0&quot;, &quot;laravel/framework&quot;: &quot;^6.2&quot;, &quot;laravel/tinker&quot;: &quot;^1.0&quot;}, 上面就是一个简单的代码包的例子，它就是一个 key/value 形式的 json 格式，key 部分是 “包名称”，value 部分是“包版本约束”。 包名称包名称包括供应商名称和项目名称，使用 / 分隔，例如上面的laravel/framework。 包版本版本格式包版本的格式应该符合 X.Y.Z 或者 vX.Y.Z 的形式， -dev、-patch、-alpha、-beta 或 -RC这些后缀是可选的。在后缀之后也可以再跟上一个数字。 例如：0.2.5、1.0.0、1.0.0-dev、1.0.0-alpha2，都是常见的版本格式。 版本格式通常在发布 composer 包的时候用到。 版本约束版本约束用在 composer.json 文件中，让 composer 安装指定版本的代码包，通常版本约束可以由以下几种方式来指定： 指定确切版本号例如：1.0.2 指定范围例如：&gt;=1.0、 &gt;=1.0,&lt;2.0、 &gt;=1.0,&lt;1.1|&gt;=1.2，有效的运算符：&gt;、&gt;=、&lt;、&lt;=、!=。你可以定义多个范围，用逗号隔开，这将被视为一个逻辑AND处理。一个管道符号 | 将作为逻辑OR处理。AND 的优先级高于 OR。 使用通配符 * 来指定一种模式例如：1.0.*，1.0.*与&gt;=1.0,&lt;1.1是等效的。 赋值运算符（~和^）例如：~1.2、^1.0.0，~1.2相当于&gt;=1.2,&lt;2.0，^1.0.0相当于&gt;=1.0.0,&lt;2.0.0。","link":"/modern-php/composer/package/"},{"title":"依赖注入容器","text":"在面向对象编程中，类与类之间应该“低耦合”，而大多数情况下单一类完成所有任务的情况很少，类之间相互调用才能体现出类的真正强大之处，因此类之间又要有所依赖。 123456class UserFinder { private $finderAdapter; public __construct(Db $db) { $this-&gt;finderAdapter = $db; }} 上面这个例子中，UserFinder类依赖于Db类，换句话说，Db类注入到了UserFinder中。 类似于上面的例子还有很多，如果依赖更多，那么用手动new的办法来实例化一个类时就要先确定它属的每个依赖，这将会让实例化变得十分繁琐： 123456$component = new Component( new A(), new B(), new C(new D()), ...); 所以，有没有一种方法能让创建对象简单化，在创建对象的时候不用去关心它所属的依赖，而让依赖注入自动化？答案就是“依赖注入容器”。 什么是“依赖注入容器”“依赖注入容器”，就是将所有类都放入一个容器中，这个容器能够自动地维护类与类之间的依赖关系，当我们要取得一个类的实例时，容器会自动的组装这个类的依赖。 “依赖注入容器”涉及到以下几个概念： IoC与DI IoC，即控制反转，把对象的调用权交给容器，通过容器来实现对象的装配和管理。 DI，即依赖注入，对象之间依赖关系由容器在运行期决定，由容器动态地将关系注入到对象之中。 谁依赖谁？对象实例化依赖容器。为什么要依赖？对象实例化通过容器自动得到外部依赖。谁注入谁？容器注入对象的依赖到对象之中。注入了什么？注入了对象的外部依赖。 “依赖注入容器”的使用现实很多框架都已实现了这样的容器，例如 yii2 框架 中的 yii\\di\\Container 类。 依赖注入方式依赖注入的基本原理就是利用PHP的“反射”特性来实现的，基本上有下面几种方式： 构造方法注入 setter注入 注解注入 下面是一个基于 yii2 框架中的 yii\\di\\Container 支持的构造方法注入方式的例子： 12345678910class Foo { public function __construct(Bar $bar) { }}$container = new yii\\di\\Container();$foo = $container-&gt;get('Foo');// 上面的代码等价于：$bar = new Bar;$foo = new Foo($bar); 依赖注入类型常见的依赖注入类型有下面两种： 简单对象注入 抽象对象注入 还是基于 yii2 框架中的 yii\\di\\Container 来举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253namespace app\\models;use yii\\base\\BaseObject;use yii\\db\\Connection;use yii\\di\\Container;interface UserFinderInterface{ function findUser();}class UserFinder extends BaseObject implements UserFinderInterface{ public $db; public function __construct(Connection $db, $config = []) { $this-&gt;db = $db; parent::__construct($config); } public function findUser() { }}class UserLister extends BaseObject{ public $finder; public function __construct(UserFinderInterface $finder, $config = []) { $this-&gt;finder = $finder; parent::__construct($config); }}$container = new Container;$container-&gt;set('yii\\db\\Connection', [ 'dsn' =&gt; '...',]);$container-&gt;set('app\\models\\UserFinderInterface', [ 'class' =&gt; 'app\\models\\UserFinder',]);$container-&gt;set('userLister', 'app\\models\\UserLister');$lister = $container-&gt;get('userLister');// 等价于:$db = new \\yii\\db\\Connection(['dsn' =&gt; '...']);$finder = new UserFinder($db);$lister = new UserLister($finder); 上面例子中，UserFinder 类采用了构造方法注入方式，构造方法中的参数 $db 是一个具体类的类型yii\\db\\Connection，这种注入类型就是“简单对象注入”。 同样，UserLister 类也采用了构造方法注入方式，但构造方法中的参数 $finder 并不是一个具体类的类型，而是一个接口类型UserFinderInterface，这种注入类型就是“抽象对象注入”。在“抽象对象注入”的使用中，我们要先确定注入接口指向的具体实现，比如上面代码中的： 123$container-&gt;set('app\\models\\UserFinderInterface', [ 'class' =&gt; 'app\\models\\UserFinder',]);","link":"/modern-php/designpatterns/di/"}],"tags":[{"name":"php","slug":"php","link":"/tags/php/"},{"name":"namespace","slug":"namespace","link":"/tags/namespace/"},{"name":"接口","slug":"接口","link":"/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"interface","slug":"interface","link":"/tags/interface/"},{"name":"抽象","slug":"抽象","link":"/tags/%E6%8A%BD%E8%B1%A1/"},{"name":"composer","slug":"composer","link":"/tags/composer/"},{"name":"自动加载","slug":"自动加载","link":"/tags/%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD/"},{"name":"autoload","slug":"autoload","link":"/tags/autoload/"},{"name":"依赖注入","slug":"依赖注入","link":"/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"},{"name":"容器","slug":"容器","link":"/tags/%E5%AE%B9%E5%99%A8/"},{"name":"Ioc","slug":"Ioc","link":"/tags/Ioc/"},{"name":"DI","slug":"DI","link":"/tags/DI/"}],"categories":[{"name":"现代PHP","slug":"现代PHP","link":"/categories/%E7%8E%B0%E4%BB%A3PHP/"},{"name":"composer","slug":"现代PHP/composer","link":"/categories/%E7%8E%B0%E4%BB%A3PHP/composer/"},{"name":"PHP基础","slug":"现代PHP/PHP基础","link":"/categories/%E7%8E%B0%E4%BB%A3PHP/PHP%E5%9F%BA%E7%A1%80/"},{"name":"设计模式","slug":"现代PHP/设计模式","link":"/categories/%E7%8E%B0%E4%BB%A3PHP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}